I"º<p>Iâ€™ve encountered a couple scenarios in which I wanted to squash the git history of a particular
branch.</p>

<!--more-->

<p>The most common is to prepare a branch for a pull request so that Iâ€™m only merging a single
commit for the feature or bug fix. I used to rebase the branch on my target (e.g. <code class="language-plaintext highlighter-rouge">master</code>) but that
often led to multiple rounds of conflict resolution as each commit was rebased. Iâ€™ve since changed
to first interactively rebasing the branch on the merge base commit so I could squash my work into
a single commit and then rebase the result of my target branch. Assuming that my feature branch has
already resolved any potential merge conflicts with my target branch, the rebases are both clear of
conflicts and the result is a nice, clean single commit of my changes.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git rebase <span class="nt">-i</span> <span class="si">$(</span>git merge-base HEAD master<span class="si">)</span> <span class="o">&amp;&amp;</span> git rebase master
</code></pre></div></div>

<p>Because I am often reviewing other engineersâ€™ code, Iâ€™ve included this within my <code class="language-plaintext highlighter-rouge">.gitconfig</code> to
simplify my workflow for prepping code to be cleanly merged.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[alias]
squash = "!f() { git rebase -i $(git merge-base HEAD $1) &amp;&amp; git rebase $1; }; f"
</code></pre></div></div>

<blockquote>
  <p><em>Note:</em> GitHub includes this feature to its UI but itâ€™s sometimes useful to do manually (or if
youâ€™re using something other than GitHub!).</p>
</blockquote>

<p>A second scenario arose as a result of the first! I had two features in different stages of
development and the second was based on the first. When the first was merged into <code class="language-plaintext highlighter-rouge">master</code>, it was
squashed down to a commit. My second branch still had the original commits of the first branch so I
didnâ€™t want to merge those into master but, more importantly in this case, I didnâ€™t want my
coworkers trying to sift through which commits were relevant to the change.</p>

<p>In this case, the commit history wasnâ€™t necessary for review so I created a new branch based on
master and <code class="language-plaintext highlighter-rouge">git apply</code>-ed the changes (from <code class="language-plaintext highlighter-rouge">git diff</code>) from my second feature branch. The result is
a set of unstages changes representing the difference between master and my feature branch.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git branch feature-branch-merge master
git checkout feature-branch-merge
git diff master feature-branch | git apply
git commit -m 'add new feature'
</code></pre></div></div>
:ET