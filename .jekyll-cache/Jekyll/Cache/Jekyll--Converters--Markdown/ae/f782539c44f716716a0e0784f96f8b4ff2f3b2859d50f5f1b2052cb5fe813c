I"Æ<p>Enyo has a pretty deep inheritance heirarcy and one of our areas of research right now is ways to
flatten it to improve performance and ease debugging. Weâ€™ve discussed increasing our use of mixins
(or something similar, perhaps) to add functionality to a kind without defining an entirely new one.
Mixins have a couple of drawbacks regarding overriding methods, however:</p>

<ol>
  <li>You have to use <code class="language-plaintext highlighter-rouge">kind.inherit</code> which is a bit awkward</li>
  <li>It still increases the call stack</li>
</ol>

<p>One common place for method overrides are the lifecycle methods (e.g. <code class="language-plaintext highlighter-rouge">create()</code>, <code class="language-plaintext highlighter-rouge">destroy()</code>). In
most cases, the mixin does its work either before or after the call to the super without modifying
the arguments. To make this a bit easier, Iâ€™m proposing a new HookSupport mixin.</p>

<!--more-->

<h2 id="how-it-works">How it works</h2>

<p>The <code class="language-plaintext highlighter-rouge">enyo/HookSupport</code> modules exports the HookSupport mixin allowing a kind to invoke a hook.
The module also provides the logic to accumulate the methods attaching to a hook via
<code class="language-plaintext highlighter-rouge">kind.concatHandler</code>.</p>

<h3 id="defining-a-hook">Defining a Hook</h3>

<p>Hooks are defined at execution time using <code class="language-plaintext highlighter-rouge">invokeHook(name, method)</code> where name is a String with
the name of the hook (e.g. <code class="language-plaintext highlighter-rouge">create</code>) and method is either the name of a method on <code class="language-plaintext highlighter-rouge">this</code> or the
method itself.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">create</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">invokeHook</span><span class="p">(</span><span class="dl">'</span><span class="s1">create</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">_create</span><span class="p">);</span>
<span class="p">},</span>
<span class="nx">_create</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
	<span class="c1">// actual work</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="attaching-to-a-hook">Attaching to a Hook</h3>

<p>You can attach to a hook from mixins, subkinds, or instances. You could even attach from the kind
that declares the hook though thatâ€™s likely not necessary. Each hook supports before and after
points to support the common use cases. To attach to a hook, add a <code class="language-plaintext highlighter-rouge">hooks</code> block to your kind or
mixin with an entry for each point you want to hook.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">hooks</span><span class="p">:</span> <span class="p">{</span>
	<span class="nl">beforeCreate</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
		<span class="c1">// this will run before the 'create' callback</span>
	<span class="p">},</span>
	<span class="c1">// this will call this.afterCreateWork() after the `create` callback</span>
	<span class="nx">afterCreate</span><span class="p">:</span> <span class="dl">'</span><span class="s1">afterCreateWork</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that hook callbacks do not receive any parameters. Further, return values are ignored. There
is no mechanism to stop either future callbacks from being invoked. I could forsee supported either
of these scenarios if there were use cases for them.</p>
:ET