---
layout: post
title: 'Enyo Daily #8 - Events - Part 3'
date: 2011-07-30 09:30 -0700
---

<p><p>In the exciting finale on events in enyo, I'll cover the <a href="https://developer.palm.com/content/api/reference/enyo/enyo-api-reference.html#enyo.ApplicationEvents" target="_blank">ApplicationEvents</a> component.  This built-in component handles the three window events (onload, onunload, and resize) as well as a host of webOS specific events.</p>
<p><em>For more background on events, check out <a href="http://blog.technisode.com/post/8155837364/enyo-daily-6-events-part-1">Part 1 on custom events</a> and <a href="http://blog.technisode.com/post/8203888586/enyo-daily-7-events-part-2">Part 2 on DOM events</a>.</em></p>
<p><em>[[MORE]]</em>The ApplicationEvents component is really just a convenience control.  It contains virtually no logic.  Instead it simply overrides dispatchDomEvent (<a href="http://blog.technisode.com/post/8203888586/enyo-daily-7-events-part-2">see Part 2 for details</a> on this method) and fires its custom events instead.  Not to say there isn't value using it; it's preferable to declaratively bind a handler via a component versus programmatically checking the event type in dispatchDomEvent.  It also  (hopefully) insulates the developer for changes to the underlying event model.  For example, if HP decided to change an event type, ApplicationEvents would be able to handle that scenario and fire its original event.</p>
<p>Because there isn't anything to ApplicationEvents, I won't spend much time discussing its features.  One notable event is onWindowRotated.</p>
<p>As you would expect, this is fired when you rotate the device (or emulator via keystrokes).  Under the covers, this event is really just a translation of the window resize event (Search for enyo.sendOrientationChange in the enyo source to see what's going on).  You'd think that you'd be able to simulate rotation in the browser by reszing the window.  Unfortunately, there's check for changes to PalmSystem.screenOrientation (which I assume is set by Palm's customized WebKit since it isn't referenced elsewhere in source) so windowRotated never fires in the browser.</p>
<p>If you want to test how your display will scale when changing from portrait to landscape, you can add a resizeHandler method to your component (<a href="http://blog.technisode.com/post/8203888586/enyo-daily-7-events-part-2">check out Part 2</a> for an explanation why you don't have to specifically listen for resize for resizeHandler to be called).  If, however, you need to test for a specific orientation, you'll have to use the emulator.</p>
<p>Here's the complete example incorporating all three types of events.</p>
<blockquote>
<p>var _Example = {<br>    name:"com.technisode.example.App",<br>    kind:"Control",<br>    components:[<br>        {kind:"ApplicationEvents", name:"appEvents"},<br>        {kind:"EventSender", name:"eventSender", onSend:"sent"},<br>        {kind:"Button", onclick:"clicked"},<br>        {kind:"Input", onkeypress:"press"}<br>    ],<br>    create:function() {<br>        this.inherited(arguments);<br>        <br>        // map all ApplicationEvents to logAppEvent<br>        var ae = this.$.appEvents;<br>        Object.keys(enyo.ApplicationEvents.prototype.events).forEach(function(key) {<br>            enyo.log("setting handler for ",key);<br>            ae[key] = "logAppEvent";<br>        })<br>    },<br>    logAppEvent:function(source, e) {<br>        enyo.log("logAppEvent",e.type);<br>    },<br>    resizeHandler:function() {<br>        enyo.log("dimensions",window.document.body.offsetWidth,window.document.body.offsetHeight);<br>    },<br>    captureDomEvent:function(e) {<br>        enyo.log("A DOM event occured", e.type);<br>        <br>        // returning true would indicated the event is captured and prevent the bubble phase<br>        // thereby preventing the declared handlers (clicked in this case) from being called<br>        <br>        // returning false (or no explicit return) lets things continue<br>        return false;<br>    },<br>    dispatchDomEvent:function(e) {<br>        // like any other method, you could override dispatchDomEvent and implement custom routing<br>        e.myCustomField = "This is a custom field";<br>        <br>        return this.inherited(arguments);<br>    },<br>    press:function(source, event) {<br>        enyo.log(source, event);<br>    },<br>    clickHandler:function(source, event) {<br>        enyo.log("bubbled up to me", event.myCustomField);<br>        <br>        // calling event.stopPropagation() or returning true will end the bubble phase<br>    },<br>    clicked:function(source, event) {<br>        // trigger my custom events<br>        this.$.eventSender.go();<br>        <br>        // toggles event handler between send and secondSent ... just because ...<br>        this.$.eventSender.onSend = (this.$.eventSender.onSend === "sent") ? "secondSent" : "sent";<br>        <br>        // calling event.stopPropagation() or returning true will end the bubble phase<br>    },<br>    sent:function(source, one, two, three) {<br>        enyo.log("sent", one, two, three)<br>    },<br>    handleOnAlert:function(source, obj) {<br>        enyo.log("alerted", enyo.json.stringify(obj));<br>    },<br>    secondSent:function(source, one, two, three) {<br>        enyo.log("secondSent handles onSend now", one, two, three)<br>    }<br>}<br><br>var _EventSender = {<br>    name:"EventSender",<br>    kind:"Component",<br>    events:{ <br>        onSend:"handleOnSend",<br>        onAlert:{value:"handleOnAlert", caller:"sendAlert"}<br>    },<br>    go:function() {<br>        this.doSend(1,2,3);    // dispatchIndirectly<br>        this.sendAlert({a:1, b:2});<br>    }<br>}<br><br>enyo.kind(_EventSender);<br>enyo.kind(_Example);</p>
</blockquote></p>